def test1():
  # Preamble Script.
  # 测试前导脚本，将来会被添加
  # Test Preamble Script To Be Added In The Future.

  # 设置安全模式转换硬度为1
  set_safety_mode_transition_hardness(1)

  # Configuration Preamble Script.
  # 配置前导脚本
  # Configuration variables.

  # 配置工具模拟IO工作模式
  set_tool_analog_io_work_mode(0)
  set_tool_digital_io_work_mode(0)

  # 配置工具模拟输入输出域
  set_tool_analog_input_domain(1)
  set_tool_analog_output_domain(1)

  # 配置工具数字IO：参数分别是(索引,模式,输入使能,输出使能)
  set_tool_digital_io_config(0,2,True,True)
  set_tool_digital_io_config(1,2,True,True)
  set_tool_digital_io_config(2,0,True,False)
  set_tool_digital_io_config(3,0,True,False)

  # 配置工具串口：使能,波特率,数据位,停止位,Modbus RTU模式,用途
  tool_serial_config(True,115200,0,1,modbus_rtu = True,usage = 1)

  # 设置工具电压为24V
  set_tool_voltage(24)

  # 设置TCP（工具中心点）偏移：[x,y,z,rx,ry,rz]
  set_tcp([0.0, 0.0, 0.0, 0.0, 0.0, 0.0])

  # 设置负载参数：重量,重心,惯量
  set_payload(0.0, [0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0])

  # 设置标准模拟输入输出域
  set_standard_analog_input_domain(0, 1)
  set_standard_analog_input_domain(1, 1)
  set_standard_analog_output_domain(0, 1)
  set_standard_analog_output_domain(1, 1)

  # 将输入动作设置为默认值
  set_input_actions_to_default()

  # 设置重力加速度方向：[x,y,z] 单位m/s²
  set_gravity([0.0, 0.0, 9.82])

  # Frame variables.
  # 帧变量定义
  # 全局帧变量：用于存储坐标系变换参数
  global u22352u26631u31995
  u22352u26631u31995 = [0.005, 0.0, 0.0, 0.0, 0.0, 0.0]

  # Temporary frame variables.
  # 临时帧变量
  # Conveyor Config
  # 传送带配置
  #--------------- Start WeldingDevice -----------------
  # 开始焊接设备相关函数定义

  # 触摸感知偏移计算函数
  # org: 原始点, dir1/dir2: 方向向量, length: 偏移长度
  def touchSenseOffset(org,dir1,dir2,length):
     # 深拷贝原始点
     pose = elicopy.deepcopy(org)
     # 计算两个方向向量的差值
     pose_diff = [0,0,0]
     pose_diff[0] = dir2[0] - dir1[0]
     pose_diff[1] = dir2[1] - dir1[1]
     pose_diff[2] = dir2[2] - dir1[2]
     # 归一化差值向量
     pose_diff = normalize(pose_diff)
     # 在偏移方向上移动指定长度
     pose[0] = pose[0] + pose_diff[0] * length
     pose[1] = pose[1] + pose_diff[1] * length
     pose[2] = pose[2] + pose_diff[2] * length
     return pose
  end

  # 全局触摸感知偏移值
  global fullTouchSenseOffsetValue
  fullTouchSenseOffsetValue = [0,0,0,0,0,0]

  # 全局触摸参考点
  global fullTouchReferencePoint
  fullTouchReferencePoint = [0,0,0,0,0,0]

  # 是否在焊接路径中
  global inWeldingPath
  inWeldingPath = False

  # 完全仿真模式标志
  global full_sim_mode
  full_sim_mode = True

  # 完全仿真模式检查线程ID
  global full_sim_mode_inspection_thread_id
  full_sim_mode_inspection_thread_id = 0

  # 完整流程状态
  global full_process
  full_process = 0

  # 当前记录值
  global full_recordCurrent
  full_recordCurrent = 0

  # 电压记录值
  global full_recordVoltage
  full_recordVoltage = 0

  # 局部坐标系到世界坐标系转换
  def pose_trans_local(world_pnt,frame):
    return pose_trans(pose_inv(frame),world_pnt)
  end

  # 世界坐标系到局部坐标系转换
  def pose_trans_world(local_pnt,frame):
    return pose_trans(frame,local_pnt)
  end

  # 计算两点之间的向量
  def two_point_get_vec(vec1,vec2):
    result=[0,0,0]
    result[0]=vec2[0]-vec1[0]
    result[1]=vec2[1]-vec1[1]
    result[2]=vec2[2]-vec1[2]
    return result
  end

  # 向量点积（内积）
  def vector_o_product(vec1,vec2):
    return vec1[0]*vec2[0]+vec1[1]*vec2[1]+vec1[2]*vec2[2]
  end

  # 向量叉积（外积）
  def vector_v_product(vec1,vec2):
    res_vec=[0,0,0]
    res_vec[0]=vec1[1]*vec2[2]-vec1[2]*vec2[1]
    res_vec[1]=vec1[2]*vec2[0]-vec1[0]*vec2[2]
    res_vec[2]=vec1[0]*vec2[1]-vec1[1]*vec2[0]
    return res_vec
  end

  # 根据三点获取垂直向量
  def get_vertical_vec_by_three_point(pnt1,pnt2,vec_pnt):
    # 计算pnt1到pnt2的向量
    vec1=[0,0,0]
    vec1[0]=pnt2[0]-pnt1[0]
    vec1[1]=pnt2[1]-pnt1[1]
    vec1[2]=pnt2[2]-pnt1[2]
    vec1=normalize(vec1)

    # 计算中点到vec_pnt的向量
    vec2=[0,0,0]
    vec2[0]=vec_pnt[0]-((pnt1[0]+pnt2[0])/2.0)
    vec2[1]=vec_pnt[1]-((pnt1[1]+pnt2[1])/2.0)
    vec2[2]=vec_pnt[2]-((pnt1[2]+pnt2[2])/2.0)
    vec2=normalize(vec2)

    # 叉积得到垂直向量
    ver_vec=vector_v_product(vec1,vec2)
    return ver_vec
  end

  # 两点触摸偏移计算
  def two_point_touch_offset(pnt1,pnt2,vec_pnt,touch1,touch2,frame):
    final_change=[0,0,0,0,0,0]

    # 转换到局部坐标系
    pnt1_local=pose_trans_local(pnt1,frame)
    pnt2_local=pose_trans_local(pnt2,frame)
    vec_pnt_local=pose_trans_local(vec_pnt,frame)
    touch1_local=pose_trans_local(touch1,frame)
    touch2_local=pose_trans_local(touch2,frame)

    # 获取垂直向量
    ver_vec=get_vertical_vec_by_three_point(pnt1_local,pnt2_local,vec_pnt_local)

    # 如果垂直向量太小，直接返回
    if abs(norm(ver_vec))<0.0001:
      return final_change
    end

    # 根据垂直向量的主要方向，将对应坐标置零
    if (abs(ver_vec[0])>abs(ver_vec[1]))&(abs(ver_vec[0])>abs(ver_vec[2])):
      pnt1_local[0]=0
      pnt2_local[0]=0
      touch1_local[0]=0
      touch2_local[0]=0
    elif (abs(ver_vec[1])>abs(ver_vec[0]))&(abs(ver_vec[1])>abs(ver_vec[2])):
      pnt1_local[1]=0
      pnt2_local[1]=0
      touch1_local[1]=0
      touch2_local[1]=0
    elif (abs(ver_vec[2])>abs(ver_vec[0]))&(abs(ver_vec[2])>abs(ver_vec[1])):
      pnt1_local[2]=0
      pnt2_local[2]=0
      touch1_local[2]=0
      touch2_local[2]=0
    else:
      return final_change
    end

    # 计算位置偏移
    final_change[0]=touch1_local[0]-pnt1_local[0]
    final_change[1]=touch1_local[1]-pnt1_local[1]
    final_change[2]=touch1_local[2]-pnt1_local[2]

    # 计算两点间的新向量
    new_vec1=two_point_get_vec(pnt1_local,pnt2_local)
    new_vec1=normalize(new_vec1)
    if abs(norm(new_vec1))<0.0001:
      return final_change
    end

    new_vec2=two_point_get_vec(touch1_local,touch2_local)
    new_vec2=normalize(new_vec2)
    if abs(norm(new_vec2))<0.0001:
      return final_change
    end

    # 计算两个向量的夹角
    angle=vector_o_product(new_vec1,new_vec2)/(norm(new_vec1)*norm(new_vec2))
    if angle>1.0:
      angle=1.0
    end
    if angle<-1.0:
      angle=-1.0
    end
    angle=acos(angle)

    if abs(angle)<0.0001:
      return final_change
    end

    # 计算判断向量（用于确定旋转方向）
    judge_vec=vector_v_product(new_vec1,new_vec2)
    if abs(norm(judge_vec))<0.0001:
      return final_change
    end
    judge_vec=normalize(judge_vec)

    # 根据判断向量的主要方向设置旋转偏移
    if abs(judge_vec[0])>0.9999:
      if judge_vec[0]>0:
        final_change[3]=angle
      else:
        final_change[3]=-angle
      end
      return final_change
    end
    if abs(judge_vec[1])>0.9999:
      if judge_vec[1]>0:
        final_change[4]=angle
      else:
        final_change[4]=-angle
      end
      return final_change
    end
    if abs(judge_vec[2])>0.9999:
      if judge_vec[2]>0:
        final_change[5]=angle
      else:
        final_change[5]=-angle
      end
      return final_change
    end

    return final_change
  end

  # 最后一点触摸偏移计算
  def last_point_touch_offset(pnt1,pnt2,vec_pnt,touch1,touch2,pnt3,touch3,frame):
    final_change=[0,0,0,0,0,0]

    # 转换到局部坐标系
    pnt3_local=pose_trans_local(pnt3,frame)
    touch3_local=pose_trans_local(touch3,frame)
    touch1_local=pose_trans_local(touch1,frame)
    touch2_local=pose_trans_local(touch2,frame)
    pnt1_local=pose_trans_local(pnt1,frame)
    pnt2_local=pose_trans_local(pnt2,frame)
    vec_pnt_local=pose_trans_local(vec_pnt,frame)

    # 获取垂直向量
    ver_vec=get_vertical_vec_by_three_point(pnt1_local,pnt2_local,vec_pnt_local)
    if abs(norm(ver_vec))<0.0001:
      return final_change
    end

    # 根据垂直向量的主要方向，将对应坐标置零
    if (abs(ver_vec[0])>abs(ver_vec[1]))&(abs(ver_vec[0])>abs(ver_vec[2])):
      pnt3_local[0]=0
      touch3_local[0]=0
      touch1_local[0]=0
      touch2_local[0]=0
    elif (abs(ver_vec[1])>abs(ver_vec[0]))&(abs(ver_vec[1])>abs(ver_vec[2])):
      pnt3_local[1]=0
      touch3_local[1]=0
      touch1_local[1]=0
      touch2_local[1]=0
    elif (abs(ver_vec[2])>abs(ver_vec[0]))&(abs(ver_vec[2])>abs(ver_vec[1])):
      pnt3_local[2]=0
      touch3_local[2]=0
      touch1_local[2]=0
      touch2_local[2]=0
    else:
      return final_change
    end

    # 计算第三个点的偏移向量
    new_vec3=two_point_get_vec(pnt3_local,touch3_local)
    if abs(norm(new_vec3))<0.0001:
      return final_change
    end

    new_vec2=two_point_get_vec(touch1_local,touch2_local)
    if abs(norm(new_vec2))<0.0001:
      return final_change
    end
    new_vec2=normalize(new_vec2)

    # 计算投影偏移
    value=vector_o_product(new_vec2,new_vec3)
    final_change[0]=new_vec2[0]*value
    final_change[1]=new_vec2[1]*value
    final_change[2]=new_vec2[2]*value

    return final_change
  end

  # 计算新的朝向点
  def cal_new_orientation_point(pnt1,pnt2,pnt3,inner_pnt,vec_pnt):
    new_vec_pnt=elicopy.deepcopy(vec_pnt)

    # 计算第一方向向量
    first_vec=two_point_get_vec(pnt1,pnt2)
    first_vec=normalize(first_vec)
    if abs(norm(first_vec))<0.0001:
        return new_vec_pnt
    end

    # 计算第二方向向量
    second_vec=two_point_get_vec(pnt1,pnt3)
    second_vec=normalize(second_vec)
    if abs(norm(second_vec))<0.0001:
        return new_vec_pnt
    end

    # 两个向量叉积得到垂直方向
    vec_dir=vector_v_product(first_vec,second_vec)
    vec_dir=normalize(vec_dir)
    if abs(norm(vec_dir))<0.0001:
     return new_vec_pnt
    end

    # 计算内点到目标点在垂直方向上的投影长度
    len=vector_o_product(vec_dir,two_point_get_vec(inner_pnt,vec_pnt))

    # 更新目标点位置
    new_vec_pnt[0]=inner_pnt[0]+vec_dir[0]*len
    new_vec_pnt[1]=inner_pnt[1]+vec_dir[1]*len
    new_vec_pnt[2]=inner_pnt[2]+vec_dir[2]*len
    return new_vec_pnt
  end

  1111111222222  # 这行代码看起来是无意义的数字，可能是调试标记

  # 完全仿真模式检查线程函数
  def full_sim_mode_inspection():
      global full_sim_mode
      global full_process
      global inWeldingPath
      last_sim_mode = full_sim_mode

      # 无限循环检查仿真模式变化
      while True:
          if full_sim_mode == last_sim_mode:
              sleep(0.5)  # 没变化则等待0.5秒
          elif full_sim_mode == False  and inWeldingPath == True:
              null  # 仿真关闭且在焊接路径中
              last_sim_mode = full_sim_mode
          elif inWeldingPath == True:
              null  # 在焊接路径中
              last_sim_mode = full_sim_mode
      end
  end

  # 错误处理ID
  global full_err_id
  full_err_id = 0

  # 错误处理函数（无限循环同步）
  def full_err():
     while True:
        sync()  # 同步操作
     end
  end

  # 启动错误处理线程
  full_err_id = start_thread(full_err, ())

  #--------------- End WeldingDevice -----------------
  #--------------- Start FullWeldingFunction -----------------

  # MAG参数集合类
  class MAGParameterSet:
    def __init__(self, process,
      work_type, expert_number, job_number, advance_air_supply, arc_starting_current,
      arc_starting_voltage, arc_start_time, time_of_transition_c, welding_current, welding_voltage,
      correction_of_inductance, speed_of_welding, backoff_distance_d, time_of_transition_e, arc_closing_current,
      arc_closing_voltage, arc_closing_time, welding_wire_reburning, delayed_supply, advance_air_supply_job,
      arc_start_time_job, speed_of_welding_job, backoff_distance_job, arc_closing_time_job, delayed_supply_job):
      self.process = process  # 工艺编号
      self.work_type = work_type  # 工作类型
      self.expert_number = expert_number  # 专家号
      self.job_number = job_number  # 作业号
      self.advance_air_supply = advance_air_supply  # 提前送气时间
      self.arc_starting_current = arc_starting_current  # 起弧电流
      self.arc_starting_voltage = arc_starting_voltage  # 起弧电压
      self.arc_start_time = arc_start_time  # 起弧时间
      self.time_of_transition_c = time_of_transition_c  # C阶段过渡时间
      self.welding_current = welding_current  # 焊接电流
      self.welding_voltage = welding_voltage  # 焊接电压
      self.correction_of_inductance = correction_of_inductance  # 电感修正
      self.speed_of_welding = speed_of_welding  # 焊接速度
      self.backoff_distance_d = backoff_distance_d  # 回退距离D
      self.time_of_transition_e = time_of_transition_e  # E阶段过渡时间
      self.arc_closing_current = arc_closing_current  # 收弧电流
      self.arc_closing_voltage = arc_closing_voltage  # 收弧电压
      self.arc_closing_time = arc_closing_time  # 收弧时间
      self.welding_wire_reburning = welding_wire_reburning  # 焊丝回烧
      self.delayed_supply = delayed_supply  # 延迟送气
      self.advance_air_supply_job = advance_air_supply_job  # 作业提前送气
      self.arc_start_time_job = arc_start_time_job  # 作业起弧时间
      self.speed_of_welding_job = speed_of_welding_job  # 作业焊接速度
      self.backoff_distance_job = backoff_distance_job  # 作业回退距离
      self.arc_closing_time_job = arc_closing_time_job  # 作业收弧时间
      self.delayed_supply_job = delayed_supply_job  # 作业延迟送气

  # MAG参数数组，包含30组预设参数
  MAGParameters = [
      MAGParameterSet(0,0,1,1,0.5,105,0.0,0.5,0.5,0,0.0,0,6.0,5,0.5,60,0.0,0.5,0,0.5,0.5,0.5,6,5,1.5,0.5),
      # ... (共30组参数，这里省略重复的)
      MAGParameterSet(29,0,1,1,0.5,105,0.0,0.5,0.5,0,0.0,0,6.0,5,0.5,60,0.0,0.5,0,0.5,0.5,0.5,6,5,1.5,0.5),
  ]

  #--------------- Start Demon -----------------
  # 获取当前客户端IP地址
  listen_address = get_current_client_ip()
  listen_port = 60010

  # 创建并联夹持器的RPC工厂实例
  parallel_gripper = rpc_factory("xmlrpc", "http://{}:{}/{}".format(listen_address, listen_port, "parallel"))

  #--------------- End Demon -----------------

  # Set Node Preamble Script.
  # 设置节点前导脚本
  # Loop Node Preamble Script.
  # 循环节点前导脚本
  # Waypoint Node Preamble Script.
  # 路径点节点前导脚本
  # Initial Variables value.
  # 初始变量值
  # Timer Node Preamble Script.
  # 定时器节点前导脚本
  # SubTask Node Preamble Script.
  # 子任务节点前导脚本
  # Before Start Preamble Script.
  # 启动前导脚本
  # Thread Node Preamble Script.
  # 线程节点前导脚本
  # Event Node Preamble Script.
  # 事件节点前导脚本
  # Main Task Script.
  # 主任务脚本

  # 主循环 - 机器人主任务
  while (True):
    $ LINE: (2, "机器人主任务")  # 调试标记：第2行，描述"机器人主任务"
    $ LINE: (3, "等待")  # 调试标记：第3行，描述"等待"
    sleep(0.01)  # 短暂延时
  end
end
